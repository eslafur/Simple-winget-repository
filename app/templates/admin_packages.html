{% extends "base.html" %}

{% block title %}Admin â€“ Packages | winget REST Repository{% endblock %}

{% block content %}
<section>
  <h2>
    Packages
    <button onclick="openNewPackageModal()" class="button-add" title="Add new package">+</button>
  </h2>
  <p>All indexed packages. Click a row to view and manage versions.</p>

  <table class="table">
    <thead>
      <tr>
        <th>Identifier</th>
        <th>Name</th>
        <th>Latest version</th>
      </tr>
    </thead>
    <tbody>
      {% for pkg in owned_packages %}
      <tr onclick="window.location.href='/admin/packages/{{ pkg.id }}'">
        <td><code>{{ pkg.id }}</code></td>
        <td>{{ pkg.name }}</td>
        <td>{{ pkg.latest_version or "-" }}</td>
      </tr>
      {% else %}
      <tr>
        <td colspan="3">No packages found.</td>
      </tr>
      {% endfor %}
    </tbody>
  </table>
</section>

<section>
  <h2>
    WinGet Index Status
  </h2>
  <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
    <span>WinGet index last pulled: <strong>{{ index_last_pulled or "never" }}</strong></span>
    <button onclick="updateWingetIndex()" class="button-secondary" title="Update WinGet index">Update Index</button>
  </div>
</section>

<section>
  <h2>
    Cached WinGet Packages
    <button onclick="openNewCachedPackageModal()" class="button-add" title="Add cached package">+</button>
  </h2>
  <p>Packages cached from the official WinGet repository. Click a row to view details and manage filters.</p>

  <table class="table">
    <thead>
      <tr>
        <th>Identifier</th>
        <th>Name</th>
        <th>Publisher</th>
        <th>Latest Version</th>
        <th>Filters</th>
        <th>Versions</th>
      </tr>
    </thead>
    <tbody>
      {% for pkg in cached_packages %}
      <tr onclick="window.location.href='/admin/cached-packages/{{ pkg.package_id }}'">
        <td><code>{{ pkg.package_id }}</code></td>
        <td>{{ pkg.package_name }}</td>
        <td>{{ pkg.publisher }}</td>
        <td>{{ pkg.latest_version or "-" }}</td>
        <td>
          <small>
            Arch: {{ pkg.filters.architectures }}<br>
            Scope: {{ pkg.filters.scopes }}<br>
            Type: {{ pkg.filters.installer_types }}<br>
            Mode: {{ pkg.filters.version_mode }}
          </small>
        </td>
        <td>{{ pkg.version_count }}</td>
      </tr>
      {% else %}
      <tr>
        <td colspan="6">No cached packages found.</td>
      </tr>
      {% endfor %}
    </tbody>
  </table>
</section>

{% include "modal.html" %}

<script>
function openNewPackageModal() {
  openModal(
    'New Package',
    '/admin/packages/new/fragment',
    '/admin/packages/new',
    'reload'
  );
}

function openNewCachedPackageModal() {
  openModal(
    'Add Cached Package',
    '/admin/cached-packages/new/fragment',
    '/admin/cached-packages/new',
    'reload'
  );
}

async function updateWingetIndex() {
  if (!confirm('This will download the latest WinGet index. This may take a few minutes. Continue?')) {
    return;
  }
  
  const button = event.target;
  const originalText = button.textContent;
  button.disabled = true;
  button.textContent = 'Updating...';
  
  try {
    const response = await fetch('/admin/winget-index/update', {
      method: 'POST',
    });
    
    const data = await response.json();
    
    if (data.success) {
      alert('Index updated successfully!');
      location.reload();
    } else {
      alert('Error: ' + (data.error || 'Failed to update index'));
      button.disabled = false;
      button.textContent = originalText;
    }
  } catch (error) {
    alert('Error: ' + error.message);
    button.disabled = false;
    button.textContent = originalText;
  }
}

// Hook into modal content loading for cached package form
const originalOnModalContentLoaded = window.onModalContentLoaded;
window.onModalContentLoaded = function(modalBody) {
  // Call original hook first (modal_form_helpers.html)
  if (originalOnModalContentLoaded) {
    originalOnModalContentLoaded(modalBody);
  }

  // Common initializer for injected modal forms:
  // - multi-select hidden fields
  // - repeatable AD group + scope rows
  const anyForm = modalBody.querySelector('form');
  if (anyForm) {
    anyForm.querySelectorAll('[data-multi-select]').forEach(group => {
      const fieldName = group.dataset.multiSelect;
      if (!fieldName) return;
      if (group.dataset.multiSelectInitialized === 'true') return;
      group.dataset.multiSelectInitialized = 'true';

      let hiddenField = anyForm.querySelector(`input[type="hidden"][name="${fieldName}"]`);
      if (!hiddenField) {
        hiddenField = document.createElement('input');
        hiddenField.type = 'hidden';
        hiddenField.name = fieldName;
        anyForm.appendChild(hiddenField);
      }

      function updateHiddenField() {
        const checkboxes = group.querySelectorAll('input[type="checkbox"]:checked');
        const values = Array.from(checkboxes)
          .map(cb => cb.value.trim())
          .filter(v => v.length > 0);
        hiddenField.value = values.join(',');
      }

      group.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', updateHiddenField);
      });
      updateHiddenField();
    });

    const container = anyForm.querySelector('[data-ad-group-scope-list]');
    if (container && container.dataset.adGroupScopeInitialized !== 'true') {
      container.dataset.adGroupScopeInitialized = 'true';
      const addBtn = anyForm.querySelector('[data-add-ad-group-scope]');
      const tmpl = anyForm.querySelector('template[data-ad-group-scope-template]');
      if (addBtn && tmpl) {
        addBtn.addEventListener('click', () => {
          const fragment = tmpl.content.cloneNode(true);
          container.appendChild(fragment);
        });
      }
      container.addEventListener('click', (e) => {
        const target = e.target;
        if (!(target instanceof HTMLElement)) return;
        if (target.matches('[data-remove-ad-group-scope]')) {
          const row = target.closest('.ad-group-scope-row');
          if (row) row.remove();
        }
      });
    }
  }
  
  // Set up filter toggle handlers for cached package form
  const form = modalBody.querySelector('#cached-package-form');
  if (form) {
    form.querySelectorAll('.filter-toggle').forEach(toggle => {
      const groupId = toggle.getAttribute('data-group-id');
      if (!groupId) return;
      
      const group = form.querySelector(`#${groupId}`);
      if (!group) return;
      
      // Function to update visibility
      function updateVisibility() {
        if (toggle.checked) {
          group.style.display = '';
        } else {
          group.style.display = 'none';
          // Uncheck all checkboxes inside the group
          group.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            cb.checked = false;
          });
          // Clear the hidden field
          const fieldName = group.getAttribute('data-multi-select');
          const hiddenField = form.querySelector(`input[type="hidden"][name="${fieldName}"]`);
          if (hiddenField) {
            hiddenField.value = '';
          }
        }
      }
      
      // Attach change handler
      toggle.addEventListener('change', updateVisibility);
      
      // Initialize visibility
      updateVisibility();
    });
  }
};
</script>
{% endblock %}


