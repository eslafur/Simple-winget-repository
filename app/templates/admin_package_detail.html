{% extends "base.html" %}

{% block title %}Admin ‚Äì {{ package_id }} | winget REST Repository{% endblock %}

{% block content %}
  <section>
  <div>
    <a href="/admin/packages" class="button-back" title="Back to packages">‚Üê</a>
  </div>

  <div class="package-layout">
    <section id="package-details">
      <h3>
        Package: <code>{{ package_id }}</code>
        <button onclick="openPackageModal('{{ package_id }}')" class="button-small button-add-regular" title="Edit package">Edit</button>
        <button onclick="confirmDeletePackage('{{ package_id }}')" class="button-delete" title="Delete package">üóëÔ∏è</button>
      </h3>
      <dl class="details-list">
        <dt>Name</dt>
        <dd>{{ package.package_name if package else '-' }}</dd>
        
        <dt>Publisher</dt>
        <dd>{{ package.publisher if package else '-' }}</dd>
        
        <dt>Description</dt>
        <dd>{{ package.short_description if package and package.short_description else '-' }}</dd>
        
        <dt>License</dt>
        <dd>{{ package.license if package and package.license else '-' }}</dd>
        
        <dt>Tags</dt>
        <dd>
          {% if package and package.tags %}
            {% for tag in package.tags %}
              <span class="tag">{{ tag }}</span>{% if not loop.last %}, {% endif %}
            {% endfor %}
          {% else %}
            -
          {% endif %}
        </dd>
      </dl>
    </section>

    <section id="versions-section">
      <h3>
        Versions
        <button onclick="openVersionModal('{{ package_id }}', 'new')" class="button-add" title="Add new version">+</button>
      </h3>

      <table class="table">
        <thead>
          <tr>
            <th>Version</th>
            <th>Architecture</th>
            <th>Scope</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {% for v in versions %}
          <tr onclick="openVersionModal('{{ package_id }}', '{{ v.version }}-{{ v.architecture }}-{{ v.scope }}')">
            <td>{{ v.version }}</td>
            <td>{{ v.architecture }}</td>
            <td>{{ v.scope }}</td>
            <td onclick="event.stopPropagation();">
              <button onclick="openVersionModalClone('{{ package_id }}', '{{ v.version }}-{{ v.architecture }}-{{ v.scope }}')" class="button-small">Upload new version</button>
              <button onclick="deleteVersion('{{ package_id }}', '{{ v.version }}-{{ v.architecture }}-{{ v.scope }}')" class="button-small button-danger">Delete</button>
            </td>
          </tr>
          {% else %}
          <tr>
            <td colspan="4">No versions found.</td>
          </tr>
          {% endfor %}
        </tbody>
      </table>
    </section>
  </div>
</section>

{% include "modal.html" %}

<script>
function openPackageModal(packageId) {
  const encodedPackageId = encodeURIComponent(packageId);
  openModal(
    'Edit Package',
    `/admin/packages/${encodedPackageId}/fragment`,
    `/admin/packages/${encodedPackageId}`,
    'reload'
  );
}

function openVersionModal(packageId, versionId) {
  const encodedVersionId = encodeURIComponent(versionId);
  const title = versionId === 'new' ? 'New Version' : 'Edit Version';
  openModal(
    title,
    `/admin/packages/${packageId}/versions/${encodedVersionId}/fragment`,
    `/admin/packages/${packageId}/versions/${encodedVersionId}`,
    'reload'
  );
}

// Optional hook invoked by the modal component after it has loaded new HTML
// into the modal body. We use this to wire up dynamic behaviour for the
// version form (nested installers + custom installer steps).
function initializeCommonModalFormUI(modalBody) {
  const form = modalBody.querySelector('form');
  if (!form) return;

  // Initialize multi-select fields so hidden inputs exist and stay updated.
  form.querySelectorAll('[data-multi-select]').forEach(group => {
    const fieldName = group.dataset.multiSelect;
    if (!fieldName) return;
    // Avoid double-binding if a page re-calls this initializer.
    if (group.dataset.multiSelectInitialized === 'true') return;
    group.dataset.multiSelectInitialized = 'true';

    let hiddenField = form.querySelector(`input[type="hidden"][name="${fieldName}"]`);
    if (!hiddenField) {
      hiddenField = document.createElement('input');
      hiddenField.type = 'hidden';
      hiddenField.name = fieldName;
      form.appendChild(hiddenField);
    }

    function updateHiddenField() {
      const checkboxes = group.querySelectorAll('input[type="checkbox"]:checked');
      const values = Array.from(checkboxes)
        .map(cb => cb.value.trim())
        .filter(v => v.length > 0);
      hiddenField.value = values.join(',');
    }

    group.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
      checkbox.addEventListener('change', updateHiddenField);
    });
    updateHiddenField();
  });

  // Initialize repeatable AD group + scope rows.
  const container = form.querySelector('[data-ad-group-scope-list]');
  if (container && container.dataset.adGroupScopeInitialized !== 'true') {
    container.dataset.adGroupScopeInitialized = 'true';
    const addBtn = form.querySelector('[data-add-ad-group-scope]');
    const tmpl = form.querySelector('template[data-ad-group-scope-template]');

    if (addBtn && tmpl) {
      addBtn.addEventListener('click', () => {
        const fragment = tmpl.content.cloneNode(true);
        container.appendChild(fragment);
      });
    }

    container.addEventListener('click', (e) => {
      const target = e.target;
      if (!(target instanceof HTMLElement)) return;
      if (target.matches('[data-remove-ad-group-scope]')) {
        const row = target.closest('.ad-group-scope-row');
        if (row) row.remove();
      }
    });
  }
}

window.onModalContentLoaded = function(modalBody) {
  // Always run the common initializer (package form, cached form, etc.)
  initializeCommonModalFormUI(modalBody);

  // Version form-specific behaviour
  const form = modalBody.querySelector('form[data-version-form="true"]');
  if (!form) {
    return;
  }

  const installerTypeSelect = form.querySelector('#installer_type');
  const nestedSection = form.querySelector('#nested-installers-section');
  const nestedTypeSelect = form.querySelector('#nested_installer_type');
  const nestedSingleRow = form.querySelector('#nested-single-row');
  const nestedPortableContainer = form.querySelector('#nested-portable-table-container');
  const nestedPortableTbody = form.querySelector('#nested-portable-tbody');
  const customSection = form.querySelector('#custom-installer-section');
  const customStepsTbody = form.querySelector('#custom-steps-tbody');
  const depsFilter = form.querySelector('#package_dependencies_filter');
  const depsGroup = form.querySelector('[data-multi-select="package_dependencies"]');

  function updateNestedLayout() {
    if (!nestedSection) return;
    const nestedType = (nestedTypeSelect && nestedTypeSelect.value) || '';
    if (!nestedType) {
      if (nestedSingleRow) nestedSingleRow.style.display = 'none';
      if (nestedPortableContainer) nestedPortableContainer.style.display = 'none';
      return;
    }

    if (nestedType === 'portable') {
      if (nestedSingleRow) nestedSingleRow.style.display = 'none';
      if (nestedPortableContainer) nestedPortableContainer.style.display = '';
    } else {
      if (nestedSingleRow) nestedSingleRow.style.display = '';
      if (nestedPortableContainer) nestedPortableContainer.style.display = 'none';
    }
  }

  function updateVisibility() {
    const type = installerTypeSelect ? installerTypeSelect.value : '';
    if (nestedSection) {
      nestedSection.style.display = type === 'zip' ? '' : 'none';
    }
    if (customSection) {
      customSection.style.display = type === 'custom' ? '' : 'none';
    }
    if (type === 'zip') {
      updateNestedLayout();
    }
  }

  function setupDynamicPortableRows(tbody) {
    if (!tbody) return;

    function createRow() {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>
          <input type="text" name="nested_relative_file_path" value="">
        </td>
        <td>
          <input type="text" name="nested_portable_command_alias" value="">
        </td>
      `;
      return tr;
    }

    function refresh() {
      let rows = Array.from(tbody.querySelectorAll('tr'));
      if (rows.length === 0) {
        tbody.appendChild(createRow());
        rows = Array.from(tbody.querySelectorAll('tr'));
      }

      // Remove completely empty rows except for the last one.
      for (let i = 0; i < rows.length - 1; i++) {
        const inputs = rows[i].querySelectorAll('input');
        const allEmpty = Array.from(inputs).every((input) => !input.value.trim());
        if (allEmpty) {
          tbody.removeChild(rows[i]);
        }
      }

      rows = Array.from(tbody.querySelectorAll('tr'));
      const last = rows[rows.length - 1];
      const lastInputs = last.querySelectorAll('input');
      const anyValue = Array.from(lastInputs).some((input) => input.value.trim());
      if (anyValue) {
        tbody.appendChild(createRow());
      }
    }

    tbody.addEventListener('input', refresh);
    refresh();
  }

  function setupDynamicCustomRows(tbody) {
    if (!tbody) return;
    
    // Get actions metadata from script tag or window variable
    let actionsMetadata = [];
    const metadataScript = document.querySelector('script[data-custom-actions]');
    if (metadataScript) {
      try {
        actionsMetadata = JSON.parse(metadataScript.textContent || metadataScript.innerHTML);
      } catch (e) {
        console.warn('Failed to parse custom actions metadata:', e);
      }
    } else if (window.customActionsMetadata) {
      actionsMetadata = window.customActionsMetadata;
    }

    function getActionMetadata(actionId) {
      return actionsMetadata.find(a => a.id === actionId) || null;
    }

    function updateArgumentFields(row, actionId, existingArgs) {
      const argsContainer = row.querySelector('.custom-args-container');
      if (!argsContainer) return;
      
      // Clear existing argument fields
      const existingFields = argsContainer.querySelectorAll('.custom-arg-field');
      existingFields.forEach(field => field.remove());
      
      const actionMeta = getActionMetadata(actionId);
      if (!actionMeta || !actionMeta.arguments) {
        // Hide all fields if no action selected or no arguments
        const jsonInput = argsContainer.querySelector('.custom-args-json');
        if (jsonInput) jsonInput.value = '';
        return;
      }
      
      // Create argument fields based on metadata
      actionMeta.arguments.forEach(argDef => {
        if (argDef.visible !== false) {
          const fieldDiv = document.createElement('div');
          fieldDiv.className = 'custom-arg-field';
          fieldDiv.setAttribute('data-arg-name', argDef.name);
          fieldDiv.style.display = 'block';
          
          const label = document.createElement('label');
          label.textContent = argDef.label || argDef.name;
          label.style.display = 'block';
          label.style.marginBottom = '4px';
          label.style.fontSize = '0.9em';
          if (argDef.required) {
            label.innerHTML += ' <span class="required">*</span>';
          }
          
          const input = document.createElement('input');
          input.type = 'text';
          input.className = 'custom-arg-input';
          input.setAttribute('data-arg-name', argDef.name);
          input.placeholder = argDef.placeholder || '';
          input.title = argDef.description || '';
          
          // Populate with existing value if available
          if (existingArgs && existingArgs[argDef.name]) {
            input.value = existingArgs[argDef.name];
          }
          
          if (argDef.required) {
            input.setAttribute('data-required', 'true');
          }
          
          fieldDiv.appendChild(label);
          fieldDiv.appendChild(input);
          
          // Attach event listener to update JSON when input changes
          input.addEventListener('input', () => updateArgumentsJson(row));
          
          // Insert before the hidden JSON input
          const jsonInput = argsContainer.querySelector('.custom-args-json');
          if (jsonInput) {
            argsContainer.insertBefore(fieldDiv, jsonInput);
          } else {
            argsContainer.appendChild(fieldDiv);
          }
        }
      });
      
      // Update JSON after populating fields
      updateArgumentsJson(row);
    }

    function updateArgumentsJson(row) {
      const argsContainer = row.querySelector('.custom-args-container');
      if (!argsContainer) return;
      
      const jsonInput = argsContainer.querySelector('.custom-args-json');
      if (!jsonInput) return;
      
      const select = row.querySelector('.custom-action-select');
      const hasAction = select && select.value;
      
      const args = {};
      const inputs = argsContainer.querySelectorAll('.custom-arg-input');
      inputs.forEach(input => {
        const value = input.value.trim();
        if (value) {
          args[input.getAttribute('data-arg-name')] = value;
        }
      });
      
      // Always send JSON object if an action is selected (even if empty)
      // This allows backend to distinguish between "no data" and "empty arguments"
      if (hasAction) {
        jsonInput.value = JSON.stringify(args);
      } else {
        jsonInput.value = '';
      }
    }

    function createRow() {
      const tr = document.createElement('tr');
      tr.setAttribute('data-step-index', 'new');
      
      const actionCell = document.createElement('td');
      const select = document.createElement('select');
      select.name = 'custom_action_type';
      select.className = 'custom-action-select';
      
      const defaultOption = document.createElement('option');
      defaultOption.value = '';
      defaultOption.textContent = '(Select action)';
      select.appendChild(defaultOption);
      
      actionsMetadata.forEach(action => {
        const option = document.createElement('option');
        option.value = action.id;
        option.textContent = action.label;
        select.appendChild(option);
      });
      
      actionCell.appendChild(select);
      
      const argsCell = document.createElement('td');
      argsCell.className = 'custom-args-container';
      const jsonInput = document.createElement('input');
      jsonInput.type = 'hidden';
      jsonInput.name = 'custom_args_json';
      jsonInput.className = 'custom-args-json';
      jsonInput.value = '';
      argsCell.appendChild(jsonInput);
      
      tr.appendChild(actionCell);
      tr.appendChild(argsCell);
      
      // Set up event handlers
      select.addEventListener('change', () => {
        updateArgumentFields(tr, select.value, null);
      });
      
      // Note: Input event listeners are attached in updateArgumentFields when fields are created
      
      return tr;
    }

    function refresh() {
      let rows = Array.from(tbody.querySelectorAll('tr'));
      if (rows.length === 0) {
        tbody.appendChild(createRow());
        rows = Array.from(tbody.querySelectorAll('tr'));
      }

      // Remove completely empty rows except for the last one.
      for (let i = 0; i < rows.length - 1; i++) {
        const select = rows[i].querySelector('select[name="custom_action_type"]');
        const jsonInput = rows[i].querySelector('.custom-args-json');
        const hasAction = select && select.value;
        const hasArgs = jsonInput && jsonInput.value && jsonInput.value.trim();
        if (!hasAction && !hasArgs) {
          tbody.removeChild(rows[i]);
        }
      }

      rows = Array.from(tbody.querySelectorAll('tr'));
      const last = rows[rows.length - 1];
      const lastSelect = last.querySelector('select[name="custom_action_type"]');
      const lastJsonInput = last.querySelector('.custom-args-json');
      const hasAction = lastSelect && lastSelect.value;
      const hasArgs = lastJsonInput && lastJsonInput.value && lastJsonInput.value.trim();
      if (hasAction || hasArgs) {
        tbody.appendChild(createRow());
      }
    }

    // Initialize existing rows
    const existingRows = Array.from(tbody.querySelectorAll('tr'));
    existingRows.forEach(row => {
      const select = row.querySelector('.custom-action-select');
      const jsonInput = row.querySelector('.custom-args-json');
      const argsContainer = row.querySelector('.custom-args-container');
      
      if (select) {
        select.addEventListener('change', () => {
          updateArgumentFields(row, select.value, null);
        });
        
        // Check if fields already exist (server-side rendered)
        const existingFields = argsContainer ? argsContainer.querySelectorAll('.custom-arg-field') : [];
        
        if (existingFields.length > 0) {
          // Fields already exist from server-side rendering, just attach listeners
          const argInputs = argsContainer.querySelectorAll('.custom-arg-input');
          argInputs.forEach(input => {
            // Check if listener already exists to avoid duplicates
            if (!input.hasAttribute('data-listener-attached')) {
              input.setAttribute('data-listener-attached', 'true');
              input.addEventListener('input', () => updateArgumentsJson(row));
            }
          });
          // Ensure JSON is up to date with current field values
          updateArgumentsJson(row);
        } else if (select.value) {
          // No fields exist yet, create them (for dynamically added rows)
          // Parse existing JSON to populate fields
          let existingArgs = null;
          if (jsonInput && jsonInput.value && jsonInput.value.trim()) {
            try {
              existingArgs = JSON.parse(jsonInput.value);
            } catch (e) {
              console.warn('Failed to parse custom args JSON:', e);
            }
          }
          
          // Update fields with existing arguments
          updateArgumentFields(row, select.value, existingArgs);
        }
      }
    });

    tbody.addEventListener('input', refresh);
    tbody.addEventListener('change', refresh);
    refresh();
  }

  if (installerTypeSelect) {
    installerTypeSelect.addEventListener('change', updateVisibility);
  }
  if (nestedTypeSelect) {
    nestedTypeSelect.addEventListener('change', updateNestedLayout);
  }

  setupDynamicPortableRows(nestedPortableTbody);
  setupDynamicCustomRows(customStepsTbody);

  // Simple client-side filter for the package dependencies multi-select.
  if (depsFilter && depsGroup) {
    depsFilter.addEventListener('input', () => {
      const term = depsFilter.value.toLowerCase();
      Array.from(depsGroup.querySelectorAll('.modal-checkbox-label')).forEach((label) => {
        const text = label.textContent || '';
        label.style.display = term && !text.toLowerCase().includes(term) ? 'none' : '';
      });
    });
  }
  updateVisibility();
}

// Validation for required fields in the version form. Returns an error
// message string when validation fails, or null/undefined when OK.
window.validateVersionForm = function(form) {
  const get = (selector) => form.querySelector(selector);

  const versionInput = get('#version');
  if (!versionInput || !versionInput.value.trim()) {
    return 'Version is required.';
  }

  const productCodeInput = get('#product_code');
  if (!productCodeInput || !productCodeInput.value.trim()) {
    return 'Product code is required.';
  }

  const installerTypeSelect = get('#installer_type');
  const installerType = installerTypeSelect ? installerTypeSelect.value : '';

  if (installerType === 'zip') {
    const nestedTypeSelect = get('#nested_installer_type');
    const nestedType = nestedTypeSelect ? nestedTypeSelect.value : '';
    if (!nestedType) {
      return 'Nested installer type is required for zip installers.';
    }

    if (nestedType === 'portable') {
      const portableRows = Array.from(
        form.querySelectorAll('#nested-portable-tbody tr')
      );
      const hasPath = portableRows.some((row) => {
        const input = row.querySelector('input[name="nested_relative_file_path"]');
        return input && input.value.trim();
      });
      if (!hasPath) {
        return 'At least one nested portable file path is required.';
      }
    } else {
      const singlePathInput = get('#nested_single_relative_file_path');
      if (!singlePathInput || !singlePathInput.value.trim()) {
        return 'Nested installer path in archive is required.';
      }
    }
  }

  if (installerType === 'custom') {
    const actionSelects = Array.from(
      form.querySelectorAll('select[name="custom_action_type"]')
    );
    const hasAction = actionSelects.some((sel) => sel.value && sel.value.trim());
    if (!hasAction) {
      return 'At least one custom installer action must be configured.';
    }
  }

  return null;
};

function openVersionModalClone(packageId, sourceVersionId) {
  const encodedSourceVersionId = encodeURIComponent(sourceVersionId);
  openModal(
    'Upload New Version',
    `/admin/packages/${packageId}/versions/new/fragment?clone_from=${encodedSourceVersionId}`,
    `/admin/packages/${packageId}/versions/new`,
    'reload'
  );
}

async function deleteVersion(packageId, versionId) {
  if (!confirm(`Delete version ${versionId}? This cannot be undone.`)) {
    return;
  }
  
  try {
    const encodedVersionId = encodeURIComponent(versionId);
    const res = await fetch(`/admin/packages/${packageId}/versions/${encodedVersionId}/delete`, {
      method: 'POST',
    });
    
    const data = await res.json();
    
    if (res.ok && data.success) {
      window.location.reload();
    } else {
      alert(data.error || 'Failed to delete version');
    }
  } catch (error) {
    alert(`Error: ${error.message}`);
  }
}

function confirmDeletePackage(packageId) {
  if (!confirm(`Delete package ${packageId} and all its versions? This cannot be undone.`)) {
    return;
  }
  
  fetch(`/admin/packages/${encodeURIComponent(packageId)}/delete`, {
    method: 'POST',
  })
    .then(res => res.json())
    .then(data => {
      if (data.success) {
        window.location.href = '/admin/packages';
      } else {
        alert(data.error || 'Failed to delete package');
      }
    })
    .catch(error => {
      alert(`Error: ${error.message}`);
    });
}
</script>
{% endblock %}
