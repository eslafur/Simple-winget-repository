{% extends "base.html" %}

{% block title %}Admin ‚Äì {{ package_id }} | winget REST Repository{% endblock %}

{% block content %}
  <section>
  <div>
    <a href="/admin/packages" class="button-back" title="Back to packages">‚Üê</a>
  </div>

  <div class="package-layout">
    <section id="package-details">
      <h3>
        Package: <code>{{ package_id }}</code>
        <button onclick="openPackageModal('{{ package_id }}')" class="button-small button-add-regular" title="Edit package">Edit</button>
        <button onclick="confirmDeletePackage('{{ package_id }}')" class="button-delete" title="Delete package">üóëÔ∏è</button>
      </h3>
      <dl class="details-list">
        <dt>Name</dt>
        <dd>{{ package.package_name if package else '-' }}</dd>
        
        <dt>Publisher</dt>
        <dd>{{ package.publisher if package else '-' }}</dd>
        
        <dt>Description</dt>
        <dd>{{ package.short_description if package and package.short_description else '-' }}</dd>
        
        <dt>License</dt>
        <dd>{{ package.license if package and package.license else '-' }}</dd>
        
        <dt>Tags</dt>
        <dd>
          {% if package and package.tags %}
            {% for tag in package.tags %}
              <span class="tag">{{ tag }}</span>{% if not loop.last %}, {% endif %}
            {% endfor %}
          {% else %}
            -
          {% endif %}
        </dd>
      </dl>
    </section>

    <section id="versions-section">
      <h3>
        Versions
        <button onclick="openVersionModal('{{ package_id }}', 'new')" class="button-add" title="Add new version">+</button>
      </h3>

      <table class="table">
        <thead>
          <tr>
            <th>Version</th>
            <th>Architecture</th>
            <th>Scope</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {% for v in versions %}
          <tr onclick="openVersionModal('{{ package_id }}', '{{ v.version }}-{{ v.architecture }}-{{ v.scope }}')">
            <td>{{ v.version }}</td>
            <td>{{ v.architecture }}</td>
            <td>{{ v.scope }}</td>
            <td onclick="event.stopPropagation();">
              <button onclick="openVersionModalClone('{{ package_id }}', '{{ v.version }}-{{ v.architecture }}-{{ v.scope }}')" class="button-small">Upload new version</button>
              <button onclick="deleteVersion('{{ package_id }}', '{{ v.version }}-{{ v.architecture }}-{{ v.scope }}')" class="button-small button-danger">Delete</button>
            </td>
          </tr>
          {% else %}
          <tr>
            <td colspan="4">No versions found.</td>
          </tr>
          {% endfor %}
        </tbody>
      </table>
    </section>
  </div>
</section>

{% include "modal.html" %}

<script>
function openPackageModal(packageId) {
  const encodedPackageId = encodeURIComponent(packageId);
  openModal(
    'Edit Package',
    `/admin/packages/${encodedPackageId}/fragment`,
    `/admin/packages/${encodedPackageId}`,
    'reload'
  );
}

function openVersionModal(packageId, versionId) {
  const encodedVersionId = encodeURIComponent(versionId);
  const title = versionId === 'new' ? 'New Version' : 'Edit Version';
  openModal(
    title,
    `/admin/packages/${packageId}/versions/${encodedVersionId}/fragment`,
    `/admin/packages/${packageId}/versions/${encodedVersionId}`,
    'reload'
  );
}

// Optional hook invoked by the modal component after it has loaded new HTML
// into the modal body. We use this to wire up dynamic behaviour for the
// version form (nested installers + custom installer steps).
window.onModalContentLoaded = function(modalBody) {
  const form = modalBody.querySelector('form[data-version-form="true"]');
  if (!form) {
    return;
  }

  const installerTypeSelect = form.querySelector('#installer_type');
  const nestedSection = form.querySelector('#nested-installers-section');
  const nestedTypeSelect = form.querySelector('#nested_installer_type');
  const nestedSingleRow = form.querySelector('#nested-single-row');
  const nestedPortableContainer = form.querySelector('#nested-portable-table-container');
  const nestedPortableTbody = form.querySelector('#nested-portable-tbody');
  const customSection = form.querySelector('#custom-installer-section');
  const customStepsTbody = form.querySelector('#custom-steps-tbody');
  const depsFilter = form.querySelector('#package_dependencies_filter');
  const depsGroup = form.querySelector('[data-multi-select="package_dependencies"]');

  function updateNestedLayout() {
    if (!nestedSection) return;
    const nestedType = (nestedTypeSelect && nestedTypeSelect.value) || '';
    if (!nestedType) {
      if (nestedSingleRow) nestedSingleRow.style.display = 'none';
      if (nestedPortableContainer) nestedPortableContainer.style.display = 'none';
      return;
    }

    if (nestedType === 'portable') {
      if (nestedSingleRow) nestedSingleRow.style.display = 'none';
      if (nestedPortableContainer) nestedPortableContainer.style.display = '';
    } else {
      if (nestedSingleRow) nestedSingleRow.style.display = '';
      if (nestedPortableContainer) nestedPortableContainer.style.display = 'none';
    }
  }

  function updateVisibility() {
    const type = installerTypeSelect ? installerTypeSelect.value : '';
    if (nestedSection) {
      nestedSection.style.display = type === 'zip' ? '' : 'none';
    }
    if (customSection) {
      customSection.style.display = type === 'custom' ? '' : 'none';
    }
    if (type === 'zip') {
      updateNestedLayout();
    }
  }

  function setupDynamicPortableRows(tbody) {
    if (!tbody) return;

    function createRow() {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>
          <input type="text" name="nested_relative_file_path" value="">
        </td>
        <td>
          <input type="text" name="nested_portable_command_alias" value="">
        </td>
      `;
      return tr;
    }

    function refresh() {
      let rows = Array.from(tbody.querySelectorAll('tr'));
      if (rows.length === 0) {
        tbody.appendChild(createRow());
        rows = Array.from(tbody.querySelectorAll('tr'));
      }

      // Remove completely empty rows except for the last one.
      for (let i = 0; i < rows.length - 1; i++) {
        const inputs = rows[i].querySelectorAll('input');
        const allEmpty = Array.from(inputs).every((input) => !input.value.trim());
        if (allEmpty) {
          tbody.removeChild(rows[i]);
        }
      }

      rows = Array.from(tbody.querySelectorAll('tr'));
      const last = rows[rows.length - 1];
      const lastInputs = last.querySelectorAll('input');
      const anyValue = Array.from(lastInputs).some((input) => input.value.trim());
      if (anyValue) {
        tbody.appendChild(createRow());
      }
    }

    tbody.addEventListener('input', refresh);
    refresh();
  }

  function setupDynamicCustomRows(tbody) {
    if (!tbody) return;

    function createRow() {
      const tr = document.createElement('tr');
      // Clone the structure of the last row to preserve action options.
      const templateRow = tbody.querySelector('tr:last-child');
      if (templateRow) {
        tr.innerHTML = templateRow.innerHTML;
        // Clear values in inputs and reset selects.
        const select = tr.querySelector('select[name="custom_action_type"]');
        if (select) {
          select.value = '';
        }
        const inputs = tr.querySelectorAll('input[name="custom_arg1"], input[name="custom_arg2"]');
        inputs.forEach((input) => {
          input.value = '';
        });
      } else {
        tr.innerHTML = `
          <td>
            <select name="custom_action_type">
              <option value="">(Select action)</option>
            </select>
          </td>
          <td><input type="text" name="custom_arg1" value=""></td>
          <td><input type="text" name="custom_arg2" value=""></td>
        `;
      }
      return tr;
    }

    function refresh() {
      let rows = Array.from(tbody.querySelectorAll('tr'));
      if (rows.length === 0) {
        tbody.appendChild(createRow());
        rows = Array.from(tbody.querySelectorAll('tr'));
      }

      // Remove completely empty rows except for the last one.
      for (let i = 0; i < rows.length - 1; i++) {
        const select = rows[i].querySelector('select[name="custom_action_type"]');
        const inputs = rows[i].querySelectorAll('input[name="custom_arg1"], input[name="custom_arg2"]');
        const hasAction = select && select.value;
        const hasArgs = Array.from(inputs).some((input) => input.value.trim());
        if (!hasAction && !hasArgs) {
          tbody.removeChild(rows[i]);
        }
      }

      rows = Array.from(tbody.querySelectorAll('tr'));
      const last = rows[rows.length - 1];
      const lastSelect = last.querySelector('select[name="custom_action_type"]');
      const lastInputs = last.querySelectorAll('input[name="custom_arg1"], input[name="custom_arg2"]');
      const hasAction = lastSelect && lastSelect.value;
      const hasArgs = Array.from(lastInputs).some((input) => input.value.trim());
      if (hasAction || hasArgs) {
        tbody.appendChild(createRow());
      }
    }

    tbody.addEventListener('input', refresh);
    tbody.addEventListener('change', refresh);
    refresh();
  }

  if (installerTypeSelect) {
    installerTypeSelect.addEventListener('change', updateVisibility);
  }
  if (nestedTypeSelect) {
    nestedTypeSelect.addEventListener('change', updateNestedLayout);
  }

  setupDynamicPortableRows(nestedPortableTbody);
  setupDynamicCustomRows(customStepsTbody);

  // Simple client-side filter for the package dependencies multi-select.
  if (depsFilter && depsGroup) {
    depsFilter.addEventListener('input', () => {
      const term = depsFilter.value.toLowerCase();
      Array.from(depsGroup.querySelectorAll('.modal-checkbox-label')).forEach((label) => {
        const text = label.textContent || '';
        label.style.display = term && !text.toLowerCase().includes(term) ? 'none' : '';
      });
    });
  }
  updateVisibility();
}

// Validation for required fields in the version form. Returns an error
// message string when validation fails, or null/undefined when OK.
window.validateVersionForm = function(form) {
  const get = (selector) => form.querySelector(selector);

  const versionInput = get('#version');
  if (!versionInput || !versionInput.value.trim()) {
    return 'Version is required.';
  }

  const productCodeInput = get('#product_code');
  if (!productCodeInput || !productCodeInput.value.trim()) {
    return 'Product code is required.';
  }

  const installerTypeSelect = get('#installer_type');
  const installerType = installerTypeSelect ? installerTypeSelect.value : '';

  if (installerType === 'zip') {
    const nestedTypeSelect = get('#nested_installer_type');
    const nestedType = nestedTypeSelect ? nestedTypeSelect.value : '';
    if (!nestedType) {
      return 'Nested installer type is required for zip installers.';
    }

    if (nestedType === 'portable') {
      const portableRows = Array.from(
        form.querySelectorAll('#nested-portable-tbody tr')
      );
      const hasPath = portableRows.some((row) => {
        const input = row.querySelector('input[name="nested_relative_file_path"]');
        return input && input.value.trim();
      });
      if (!hasPath) {
        return 'At least one nested portable file path is required.';
      }
    } else {
      const singlePathInput = get('#nested_single_relative_file_path');
      if (!singlePathInput || !singlePathInput.value.trim()) {
        return 'Nested installer path in archive is required.';
      }
    }
  }

  if (installerType === 'custom') {
    const actionSelects = Array.from(
      form.querySelectorAll('select[name="custom_action_type"]')
    );
    const hasAction = actionSelects.some((sel) => sel.value && sel.value.trim());
    if (!hasAction) {
      return 'At least one custom installer action must be configured.';
    }
  }

  return null;
};

function openVersionModalClone(packageId, sourceVersionId) {
  const encodedSourceVersionId = encodeURIComponent(sourceVersionId);
  openModal(
    'Upload New Version',
    `/admin/packages/${packageId}/versions/new/fragment?clone_from=${encodedSourceVersionId}`,
    `/admin/packages/${packageId}/versions/new`,
    'reload'
  );
}

async function deleteVersion(packageId, versionId) {
  if (!confirm(`Delete version ${versionId}? This cannot be undone.`)) {
    return;
  }
  
  try {
    const encodedVersionId = encodeURIComponent(versionId);
    const res = await fetch(`/admin/packages/${packageId}/versions/${encodedVersionId}/delete`, {
      method: 'POST',
    });
    
    const data = await res.json();
    
    if (res.ok && data.success) {
      window.location.reload();
    } else {
      alert(data.error || 'Failed to delete version');
    }
  } catch (error) {
    alert(`Error: ${error.message}`);
  }
}

function confirmDeletePackage(packageId) {
  if (!confirm(`Delete package ${packageId} and all its versions? This cannot be undone.`)) {
    return;
  }
  
  fetch(`/admin/packages/${encodeURIComponent(packageId)}/delete`, {
    method: 'POST',
  })
    .then(res => res.json())
    .then(data => {
      if (data.success) {
        window.location.href = '/admin/packages';
      } else {
        alert(data.error || 'Failed to delete package');
      }
    })
    .catch(error => {
      alert(`Error: ${error.message}`);
    });
}
</script>
{% endblock %}
