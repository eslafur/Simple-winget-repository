<!-- Generalized Modal Component -->
<div id="modal" class="modal hidden" data-submit-endpoint="" data-close-action="close">
  <div class="modal-backdrop" onclick="closeModal()"></div>
  <div class="modal-content">
    <div class="modal-header">
      <h3 id="modal-title">Modal</h3>
      <button onclick="closeModal()" class="modal-close">&times;</button>
    </div>
    <div class="modal-body" id="modal-body">
      <!-- Content loaded via AJAX -->
    </div>
    <div id="upload-progress-container" class="upload-progress-container hidden">
      <div class="upload-progress-bar">
        <div id="upload-progress-fill" class="upload-progress-fill"></div>
      </div>
      <div id="upload-progress-text" class="upload-progress-text">0%</div>
    </div>
    <div class="modal-footer">
      <button type="button" id="modal-submit" class="button-primary" onclick="submitModal()">Submit</button>
      <button type="button" id="modal-close" class="button-secondary" onclick="closeModal()">Close</button>
    </div>
  </div>
</div>

<script>
let currentForm = null;

function openModal(title, fragmentUrl, submitEndpoint, closeAction = 'close') {
  const modal = document.getElementById('modal');
  const modalBody = document.getElementById('modal-body');
  const modalTitle = document.getElementById('modal-title');
  const modalSubmit = document.getElementById('modal-submit');
  
  modalTitle.textContent = title;
  modal.setAttribute('data-submit-endpoint', submitEndpoint || '');
  modal.setAttribute('data-close-action', closeAction);
  modalBody.innerHTML = '<p>Loading...</p>';
  modal.classList.remove('hidden');
  
  // Hide submit button initially, will be shown when form loads
  modalSubmit.style.display = 'none';
  
  fetch(fragmentUrl)
    .then(res => res.text())
    .then(html => {
      modalBody.innerHTML = html;
      // Find the form in the loaded content
      currentForm = modalBody.querySelector('form');
      if (currentForm) {
        // Show submit button if form exists
        modalSubmit.style.display = 'inline-block';
        // Update submit button text from form if available
        const formSubmit = currentForm.querySelector('button[type="submit"]');
        if (formSubmit) {
          modalSubmit.textContent = formSubmit.textContent || 'Submit';
        }
      } else {
        modalSubmit.style.display = 'none';
      }

      // Let pages hook into modal content loading (used for dynamic form UI).
      if (typeof window.onModalContentLoaded === 'function') {
        window.onModalContentLoaded(modalBody);
      }
    })
    .catch(error => {
      modalBody.innerHTML = `<p class="error">Error loading form: ${error.message}</p>`;
      modalSubmit.style.display = 'none';
    });
}

function closeModal() {
  const modal = document.getElementById('modal');
  const closeAction = modal.getAttribute('data-close-action');
  const progressContainer = document.getElementById('upload-progress-container');
  
  modal.classList.add('hidden');
  currentForm = null;
  if (progressContainer) {
    progressContainer.classList.add('hidden');
  }
  
  if (closeAction === 'reload') {
    window.location.reload();
  }
}

async function submitModal() {
  if (!currentForm) {
    alert('No form to submit');
    return;
  }
  
  const modal = document.getElementById('modal');
  // Check for form-specific endpoint, fallback to modal endpoint
  const submitEndpoint = currentForm.dataset.submitEndpoint || modal.getAttribute('data-submit-endpoint');
  const submitButton = document.getElementById('modal-submit');
  const progressContainer = document.getElementById('upload-progress-container');
  const progressFill = document.getElementById('upload-progress-fill');
  const progressText = document.getElementById('upload-progress-text');

  // Optional per-form validation hook (used by the version editor).
  if (
    currentForm.dataset.versionForm === 'true' &&
    typeof window.validateVersionForm === 'function'
  ) {
    const errorMessage = window.validateVersionForm(currentForm);
    if (errorMessage) {
      alert(errorMessage);
      return;
    }
  }
  
  if (!submitEndpoint) {
    // Try to submit the form directly if it has its own handler
    const formSubmit = currentForm.querySelector('button[type="submit"]');
    if (formSubmit) {
      formSubmit.click();
      return;
    }
    alert('No submit endpoint configured');
    return;
  }
  
  // Process multi-select fields before creating FormData
  processMultiSelectFields(currentForm);
  
  const formData = new FormData(currentForm);
  
  // Check if there's a file upload
  const fileInput = currentForm.querySelector('input[type="file"]');
  const hasFile = fileInput && fileInput.files && fileInput.files.length > 0;
  
  const originalText = submitButton.textContent;
  submitButton.disabled = true;
  submitButton.textContent = 'Saving...';
  
  // Show progress bar if file upload
  if (hasFile && progressContainer && progressFill && progressText) {
    progressContainer.classList.remove('hidden');
    progressFill.style.width = '0%';
    progressText.textContent = '0%';
  }
  
  try {
    // Use XMLHttpRequest for file uploads to track progress
    if (hasFile) {
      await submitWithProgress(submitEndpoint, formData, progressFill, progressText);
    } else {
      // Use fetch for non-file uploads
      const res = await fetch(submitEndpoint, {
        method: 'POST',
        body: formData,
      });
      
      const data = await res.json();
      
      if (!res.ok || !data.success) {
        throw new Error(data.error || 'Failed to save');
      }
    }
    
    // Success - close modal and reload if needed
    if (progressContainer) {
      progressContainer.classList.add('hidden');
    }
    closeModal();
    if (modal.getAttribute('data-close-action') === 'reload') {
      window.location.reload();
    }
  } catch (error) {
    alert(`Error: ${error.message}`);
    submitButton.disabled = false;
    submitButton.textContent = originalText;
    if (progressContainer) {
      progressContainer.classList.add('hidden');
    }
  }
}

/**
 * Process multi-select fields: update hidden fields with comma-separated values
 * This handles fields marked with data-multi-select="true"
 */
function processMultiSelectFields(form) {
  // Find all multi-select groups
  form.querySelectorAll('[data-multi-select]').forEach(group => {
    const fieldName = group.dataset.multiSelect;
    const checkboxes = group.querySelectorAll('input[type="checkbox"]:checked');
    const values = Array.from(checkboxes)
      .map(cb => cb.value.trim())
      .filter(v => v.length > 0);
    
    // Find or create hidden field
    let hiddenField = form.querySelector(`input[type="hidden"][name="${fieldName}"]`);
    if (!hiddenField) {
      hiddenField = document.createElement('input');
      hiddenField.type = 'hidden';
      hiddenField.name = fieldName;
      form.appendChild(hiddenField);
    }
    
    // Set comma-separated value (empty string if none selected)
    hiddenField.value = values.join(',');
  });
}

function submitWithProgress(endpoint, formData, progressFill, progressText) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    
    xhr.upload.addEventListener('progress', (e) => {
      if (e.lengthComputable) {
        const percentComplete = (e.loaded / e.total) * 100;
        const rounded = Math.round(percentComplete);
        progressFill.style.width = percentComplete + '%';
        progressText.textContent = rounded + '%';
      }
    });
    
    xhr.addEventListener('load', () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        try {
          const data = JSON.parse(xhr.responseText);
          if (data.success) {
            progressFill.style.width = '100%';
            progressText.textContent = '100%';
            resolve(data);
          } else {
            reject(new Error(data.error || 'Failed to save'));
          }
        } catch (e) {
          reject(new Error('Invalid response from server'));
        }
      } else {
        reject(new Error(`Server error: ${xhr.status}`));
      }
    });
    
    xhr.addEventListener('error', () => {
      reject(new Error('Network error occurred'));
    });
    
    xhr.addEventListener('abort', () => {
      reject(new Error('Upload cancelled'));
    });
    
    xhr.open('POST', endpoint);
    xhr.send(formData);
  });
}
</script>

